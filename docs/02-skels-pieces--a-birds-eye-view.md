title: Chapter 2: Skel's Pieces -- A Bird's Eye View
contentClass: page
author: Kael Shipman
dateCreated: 2017-01-26

Arguably one of the most difficult aspects of understanding Skel is zooming out and taking in the entire landscape of interfaces and how they interact. This is because Skel is actually a tiny beginning of the project to map out all possible program interfaces. It is a taxonomy project, similar to biologists' attempts to define and describe species.

Currently, though, Skel focuses on a very narrow range of interfaces -- something like "primates" in our biology example. The category of primates is relatively small, and the interactions among primates are relatively easy to define. In the same way, Skel currently deals only with interfaces having to do with web applications frameworks.

"Zooming out" too far, then, is equivalent to trying to figure out how all organisms on Earth interact and affect each other -- clearly a fruitless pursuit in all but the most ambitious of cases. While this will eventually be a useful exercise, currently it's not.

Still, with this chapter I'd like to attempt to at least describe the Skel interfaces at a high level in the narrow scope of web applications frameworks. This is, of course, not the only scope in which the interfaces are pertinent, but it is the current use case, and should provide an idea of how they can be useful.

### Overview of Interfaces

After reading the following descriptions, you should have an idea of the roles and responsibilities of the components each interface represents, and how the components work together to create an efficient, flexible and loosely-coupled web application. You should understand which features are expected to be built into the framework that the interfaces define and which features are to be implemented by each specific application that uses the framework.

Without further ado....

#### [Component](/docs/apx-a-api-docs#component) {id=component}

`Component` is the humble provider of almost all of the benefit of the Skel concept. `Component` is effectively the communications protocol that allows application logic to remain reusable in contexts never imagined by the application's creators.

A `Component` is simply a coupling of data with a method for displaying it (a `Template`). By packaging these two elements together, the data can remain structured and changable all the way up to the point of final render on screen, while at the same time allowing any application logic that has a preference about how the data is displayed to affect that. This allows libraries to build upon one another, passing `Component` objects through, adding, changing and removing fields, changing display templates, etc. 

In the real world, a `Component` will often represent a formal data object ([`DataClass`](#dataclass), in Skel speak) that maps back to a database. It certainly doesn't have to, though. In fact, at its most basic, a `Component` is a simple array with no requirements about what data it holds. This allows for the creation on the fly of anonymous `Component`s, allowing programmers to create simple, lightweight applications without the burden of too many formal definitions. (This lack of definition does have its downsides, but so far it has been more advantageous than not.)

##### Methods

`Component`s' data elements are set and retrieved using array notation (which requires implementation of PHP's `ArrayAccess` interface, the interface from which `Component` is extended). On top of that, a `Component` has only three methods: `getTemplate`, `setTemplate` and `render`, all of which do exactly what you would expect. Since a `Component` is a very natural representation of a standard tree structure, it is assumped that `render` is a recursive call that flattens the tree into a single string for display. (A `Template` doesn't have to just return a string, though, as we'll explore later.)

##### Interacts With....

A `Component` is usually generated by an `App` method, a `Db`, or a `Cms`. This is because `Db`s and `Cms`es are responsible for retrieving structured data objects that often occupy a position on screen, and an `App` fits these structured data objects into more general structured data objects that form the user interface as a whole.

`Component` also requires a `Template` instance to render into.

In general, `Component`'s primary domain is as a medium for the manipulation and display of data within an `App`, and so it will primarily be used in the context of objects that generate and manipulate displayable data.

##### Related Minor Interfaces

###### DefinedComponent

`DefinedComponent` simply allows you to create a list of "known fields" that other objects (like an ORM system) can use to manipulate the object.

###### ComponentCollection

A `ComponentCollection`, as the name implies, is a collection of `Component`s. It has methods like `filter` and `contains` that allow you to query the `Component`s it manages. This is useful for building a sort of "poor man's database cache".

It is intended to be renderable, and the official implementations offer a renderable version which simply concatenates all rendered components using newlines. However, this behavior is not defined by the interface itself.

##### Examples

At its simplest, a `Component` may be created and rendered like so:

```
<?php

$me = new PersonComponent();

$me['name'] = 'Joe Aristocrat';
$me['profession'] = 'Governor';
$me['age'] = 38;
$me['uniqueId'] = 'joe-aristocrat1';

$me->setTemplate(new StringTemplate('
  <div class="person" data-uniqueId="#\#uniqueId#\#">
    <p class="name">#\#name#\# (#\#age#\#)</p>
    <p class="profession">#\#profession#\#</p>
  </div>')
);

echo $me->render();

```

Later on, another app might use this data to add a `yearOfBirth` property to the component, to parse out the first and last name, and to specify a work category based on the profession. It might then update the template with a new template that can display all of the extra data as well as the original data.

-----------------------

#### [App](/docs/apx-a-api-docs#app) {id=app}

While `Component` is the data transport medium in the Skel world, `App` is the actual structure and backbone on which libraries are created. Since `App` extends `Context`, which extends `Observable`, all implementations of `App` are capable of registering event listeners and also of serving as a Context for methods that require one (more below).

Because of this, an `App` (which can also be considered an application library) can fire its own custom events and request and/or provide specific strings, allowing it to function as a submodules of other apps.

`App`'s primary domain, though, is as a bridge between the user interface and the datalayer. In classical MVC, this is the controller. I've broken with this terminology, though, because I thought it was a little too limiting. Since there's much that the `App` can do to affect the display of view components, and since the datalayer is not really a "model" in the classical sense, it didn't seem to make sense to mash Skel into the description of an MVC pattern.

It's important to remember that an `App` is not limited to serving a web interface across an HTTP connection. In fact, one of the primary motivations for building Skel was to encourage the creation of application libraries that could do more than just serve web interfaces. To this end, `App` is meant to be the container for custom application logic, and to use that logic to serve up its primary interface in the form of nested `Component`s, as mentioned in the previous section.

##### Methods

The primary method used in `App` is `getResponse`. This method accepts a `Request` object and returns a `Response` object. This is the "soup to nuts" method, typically calling on the `Router` to route the request and possibly generating errors or initiating a redirect. It's also a ripe place for events to fire. In the official implementation, there are a number of events that fire, including `BeforeRouting`, `ComponentCreated` and `ResponseCreated`. These allow third parties to hook into the execution and affect certain aspects of the program (the `Request` that the app is executing on, for example, or the `Component` returned by the app logic to be turned into a response).

Other methods include `str` for getting strings, `getError` (for getting a pre-composed error Component), and `redirect`, among others.

##### Interacts With....

In its capacity as bridge, an `App` will often coordinate the use of a `Db` and a `Cms` and require a `Config` instance that will supply it with information about where to find front-end materials like templates and images. Other types of `App`s (like `AccessControlledApp`, for example) will likely coordinate other systems, such as User Authentication systems and Permissions systems, which are yet to be created.

As mentioned previously, an `App` is fed a `Request` object and returns a `Response` object. The custom application logic for each specific app will also return `Component` objects, and will very likely create various types of `Template` objects.

This is the large and diverse family of the `App`.

##### Examples

Because in a way `App` is meant to be a skeleton for a class implementing the Template Method pattern, it's hard to give a useful example of it. Still, there are a few principles that may come in handy. Consider the following:

```
<?php

// Initialize everything

$config = new \MyBrand\Config('app-config');
$app = new \MyBrand\App(
  $config,
  new \Skel\Router(),
  new \MyBrand\Db($config),
  new \MyBrand\Cms($config)
);

// Now connect a few things...

$app
  ->registerListener('Error', $app, 'prepareUiForError')
  ->registerListener('ComponentCreated', $app, 'prepareSiteComponent')
  ->getRouter()
    ->addRoute(new \Skel\Route('/{section}/*', $app, 'getNormalPage', 'GET', 'page'))
    ->addRoute(new \Skel\Route('/', $app, 'getPage', 'GET', 'home'))
;

// Note: `\Skel\Request::createFromGlobals` is a function from Symfony's `Request` implementation,
// which I've used as the basis of the Skel `Request` class
$response = $app->getResponse(\Skel\Request::createFromGlobals());

// Do some more stuff to `$response` if desired, or just send....
$response->send();

```

------------------------

#### [Config](/docs/apx-a-api-docs#config) {id=config}

The `Config` interfaces are the result of an interesting idea I had to try to make configurations more formal while still offering the possibility of localized configuration tweaks and special stubs and mocks for testing.

In short, each configurable component (`App`, `Db`, `Cms`, `User`, whatever....) defines its required configurations as methods in a special `*Config` interface. Then you implement all of the necessary `*Config` interfaces in one single `Config` class (which may be extended from a base class that implements certain of the configuration methods).

The point here is not to hard-code your configurations into the class methods, since that wouldn't allow you the flexibility of easy local config variations. The point is that each configurable component requires a config object with a known set of config-getting methods, and if your `Config` class doesn't implement all of the necessary methods, you get a warning (up front, rather than something way down the line that quietly messes up when your users are doing something important).

The other advantage to this, as demonstrated by the offical `Config` implementation, is that you can create a method that calls each config method individually to verify that they all return something useful. This can alert you up front to missing configuration keys.

##### Methods

These necessarily change according to what you need configurations for, but the one universal configuration method is `getExecutionProfile`. This should tell you whether you're in beta, production, testing, or whatever other environments you define.

The other two basic methods are `checkConfig` and `dump`, both of which are debugging methods to help figure out whether you have configuration issues and what they are.

Beyond that, each derivative interface defines getter methods that should return the configuration needed for whatever they were created for. For example, `AppConfig` defines `getContextRoot`, `getPublicRoot` and `getTemplateDir` -- all methods that tell an app where its important directories are located.

##### Interacts With....

This can interact with any class that might require a changable config. These tend to be the "system" classes, like `App`, `Db`, and `Cms`, though it's conceivable that you might want to change the way other classes work using a config (allowing or disallowing the creation of anonymous `Component`s, for example).

##### Examples

```
<?php

// You've ostensibly implemented the necessary `Config` interfaces in
// your own custom `Config` class in your `MyBrand` namespace
$config = new \MyBrand\Config('app-config');

// If we're in beta, check the config for errors
if ($config->getExecutionProfile == $config::PROF_BETA) $config->checkConfig();

$db = new \MyBrand\Db($config);
$cms = new \MyBrand\Cms($config);
$router = new \Skel\Router();
$app = new \MyBrand\App($config, $router, $db, $cms);

// Do something....
```


### Work In Progress

Sorry, still working on the rest!

